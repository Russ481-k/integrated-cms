# 고도화된 관리자 권한 시스템 개념 설계

## 1. 시스템 개요

### 1.1 설계 목표

통합 CMS에서는 개별 사이트와 통합 관리 사이트 모두에서 유연하고 세분화된 관리자 권한 관리가 필요합니다. 이를 위해 **RBAC (Role-Based Access Control)** + **ABAC (Attribute-Based Access Control)** 하이브리드 모델을 채택합니다.

### 1.2 핵심 요구사항

#### 1.2.1 개별 사이트 관리자 관리

- 사이트 선택 불가능 (해당 사이트만 관리)
- 사용자 선택 가능
- 메뉴 선택 가능
- 메뉴 내 주요 기능 권한 지정 가능

#### 1.2.2 통합 사이트 관리자 관리

- 사이트 선택 가능 (모든 개별 사이트 + 통합 관리 사이트)
- 사용자 선택 가능
- 메뉴 선택 가능
- 메뉴 내 주요 기능 권한 지정 가능
- 개별 사이트 관리자의 권한까지 설정 가능

### 1.3 권한 모델 구조

```
통합 관리자 (SUPER_ADMIN)
    ├── 개별 서비스 관리 권한
    ├── 통합 시스템 관리 권한
    └── 타 관리자 권한 설정 권한

개별 서비스 관리자 (SERVICE_ADMIN)
    ├── 해당 서비스만 관리 권한
    └── 서비스 내 사용자 권한 설정

일반 관리자 (OPERATOR)
    └── 할당된 메뉴/기능만 접근 권한
```

### 1.4 권한 검증 우선순위

1. **명시적 거부 권한** (DENY) - 최우선, 모든 다른 권한을 무효화
2. **개별 사용자 명시적 허용 권한** (USER ALLOW)
3. **그룹을 통한 허용 권한** (GROUP ALLOW)
4. **역할 기반 기본 권한** (ROLE PERMISSION)
5. **기본 거부** (권한 없음)

## 2. 권한 검증 로직

### 2.1 권한 검증 플로우

권한 시스템의 핵심은 빠르고 정확한 권한 검증입니다. 다음과 같은 단계적 검증 프로세스를 따릅니다:

#### 2.1.1 1단계: 캐시 확인

- Redis를 활용한 권한 결과 캐싱 (TTL: 15분)
- 캐시 키 패턴: `permission:{adminId}:{serviceCode}:{permissionCode}`
- 캐시 히트 시 즉시 결과 반환

#### 2.1.2 2단계: 명시적 거부 권한 검사

- 사용자별/그룹별 명시적 DENY 권한 확인
- DENY 권한 발견 시 즉시 접근 거부
- 최고 우선순위 적용

#### 2.1.3 3단계: 명시적 허용 권한 검사

- 사용자별 명시적 ALLOW 권한 확인
- 그룹을 통한 ALLOW 권한 확인
- 명시적 허용 시 즉시 접근 허용

#### 2.1.4 4단계: 역할 기반 권한 검사

- 할당된 역할의 기본 권한 확인
- 서비스별 역할 할당 상태 검증
- 권한 만료 시간 확인

#### 2.1.5 5단계: 기본 거부

- 모든 조건 만족하지 않을 시 접근 거부
- 최소 권한 원칙 적용

### 2.2 메뉴 접근 권한 검증

메뉴별 접근 권한은 더욱 세분화된 검증 과정을 거칩니다:

#### 2.2.1 메뉴 정보 검증

- 메뉴 존재 여부 확인
- 메뉴 활성화 상태 확인
- 서비스별 메뉴 소속 확인

#### 2.2.2 메뉴별 명시적 권한 검사

- admin_menu_permissions 테이블 조회
- DENY 권한 우선 검사
- ALLOW 권한 확인

#### 2.2.3 메뉴 필수 권한 검사

- required_permissions JSON 필드 파싱
- 필수 권한 모두 보유 확인
- AND 조건으로 모든 권한 확인

### 2.3 세부 기능 권한 검증

메뉴 내 특정 기능(생성, 수정, 삭제 등)에 대한 권한 검증:

#### 2.3.1 기본 메뉴 접근 권한 선행 확인

- 메뉴 접근 권한 없을 시 즉시 거부

#### 2.3.2 기능별 세부 권한 검사

- specific_permissions JSON 필드 확인
- 기능별 DENY/ALLOW 권한 검증
- 역할 기반 기본 기능 권한 확인

## 3. 관리자 관리 기능

### 3.1 관리자 계정 관리

#### 3.1.1 관리자 생성 프로세스

1. **중복성 검증**: 사용자명, 이메일 중복 확인
2. **비밀번호 암호화**: bcrypt 해싱 적용
3. **기본 정보 설정**: 부서, 직책, 시간대, 언어 설정
4. **초기 상태 설정**: PENDING_APPROVAL 상태로 생성
5. **기본 그룹 할당**: 필요 시 기본 그룹에 자동 추가
6. **감사 로그 기록**: 생성 작업 로그 남김

#### 3.1.2 관리자 상태 관리

- **ACTIVE**: 정상 활성 상태
- **INACTIVE**: 비활성 상태 (로그인 불가)
- **LOCKED**: 계정 잠금 상태 (로그인 실패 횟수 초과)
- **PENDING_APPROVAL**: 승인 대기 상태

#### 3.1.3 보안 정책

- 연속 로그인 실패 시 계정 임시 잠금
- 비밀번호 변경 주기 관리
- 세션 타임아웃 설정
- 2FA 지원 (선택사항)

### 3.2 서비스별 역할 할당

#### 3.2.1 역할 할당 규칙

- 관리자당 서비스별로 하나의 주 역할 할당
- 역할 중복 할당 방지
- 역할 레벨 기반 상하 관계 확인
- 권한 만료 시간 설정 가능

#### 3.2.2 할당 타입

- **개별 할당**: 특정 관리자에게 직접 역할 할당
- **그룹 할당**: 그룹을 통한 역할 상속
- **임시 할당**: 기간 제한이 있는 역할 할당

#### 3.2.3 권한 상속 구조

```
통합 시스템 권한 (service_id = NULL)
    ├── 모든 개별 서비스 접근 가능
    └── 타 관리자 권한 설정 가능

개별 서비스 권한 (service_id = specific)
    ├── 해당 서비스만 접근 가능
    └── 서비스 내 사용자 권한 설정 가능
```

### 3.3 메뉴별 세부 권한 설정

#### 3.3.1 권한 설정 범위

- **FULL**: 메뉴의 모든 기능 접근 가능
- **PARTIAL**: 지정된 기능만 접근 가능
- **READ_ONLY**: 조회만 가능

#### 3.3.2 세부 기능 권한

- **create**: 생성 권한
- **read**: 조회 권한
- **update**: 수정 권한
- **delete**: 삭제 권한
- **publish**: 발행 권한
- **approve**: 승인 권한

#### 3.3.3 조건부 권한

- SpEL 표현식을 통한 동적 권한 제어
- 시간, 사용자 속성, 데이터 상태에 따른 권한 변경
- 예: `#admin.department == 'IT' and #content.status != 'PUBLISHED'`

### 3.4 그룹 관리

#### 3.4.1 그룹 유형

- **SYSTEM**: 시스템 기본 그룹 (삭제 불가)
- **DEPARTMENT**: 부서별 그룹
- **PROJECT**: 프로젝트별 그룹
- **CUSTOM**: 커스텀 그룹

#### 3.4.2 계층적 그룹 구조

- 상위 그룹의 권한 자동 상속
- 그룹 레벨을 통한 계층 관리
- 순환 참조 방지 검증

#### 3.4.3 멤버십 관리

- **OWNER**: 그룹 소유자 (그룹 설정 변경 가능)
- **ADMIN**: 그룹 관리자 (멤버 추가/제거 가능)
- **MEMBER**: 일반 멤버 (권한만 상속)

## 4. 성능 최적화 전략

### 4.1 캐싱 전략

#### 4.1.1 권한 결과 캐싱

- Redis를 통한 권한 검증 결과 캐싱
- 캐시 TTL: 15분 (권한 변경 빈도 고려)
- 캐시 무효화: 권한 변경 시 관련 캐시 즉시 삭제

#### 4.1.2 메뉴 구조 캐싱

- 서비스별 메뉴 트리 구조 캐싱
- 메뉴 변경 시에만 캐시 무효화
- JSON 형태로 직렬화하여 캐싱

#### 4.1.3 역할 권한 매핑 캐싱

- 역할별 권한 목록 캐싱
- 역할 권한 변경 시 캐시 무효화
- 메모리 기반 로컬 캐시와 Redis 조합 사용

### 4.2 데이터베이스 최적화

#### 4.2.1 인덱스 최적화

- 권한 검증 쿼리에 필요한 복합 인덱스 생성
- 카디널리티가 높은 컬럼 우선 배치
- 사용 빈도가 낮은 인덱스 정기적 검토

#### 4.2.2 쿼리 최적화

- N+1 문제 방지를 위한 페치 조인 사용
- 서브쿼리 대신 EXISTS 절 활용
- 배치 권한 검증을 위한 IN 절 최적화

#### 4.2.3 파티셔닝

- 대용량 로그 테이블의 월별 파티셔닝
- 히스토리 데이터의 아카이빙 정책
- 읽기 전용 복제본을 통한 조회 성능 향상

### 4.3 애플리케이션 최적화

#### 4.3.1 권한 검증 배치 처리

- 여러 권한을 한 번에 검증하는 배치 API
- 불필요한 권한 검증 호출 최소화
- 권한 검증 결과의 애플리케이션 레벨 캐싱

#### 4.3.2 비동기 처리

- 권한 변경 시 비동기 캐시 무효화
- 감사 로그 비동기 기록
- 이벤트 드리븐 아키텍처 적용

#### 4.3.3 메모리 최적화

- 권한 객체의 경량화
- 불필요한 데이터 로딩 방지
- 커넥션 풀 최적화

## 5. 보안 고려사항

### 5.1 권한 누수 방지

#### 5.1.1 최소 권한 원칙

- 기본적으로 모든 접근 거부
- 명시적 권한 부여 시에만 접근 허용
- 불필요한 권한 자동 회수

#### 5.1.2 권한 분리

- 읽기 권한과 쓰기 권한 분리
- 일반 작업 권한과 관리 권한 분리
- 민감한 데이터 접근 권한 별도 관리

#### 5.1.3 시간 제한 권한

- 임시 권한의 자동 만료
- 장기간 미사용 권한 자동 회수
- 정기적인 권한 검토 프로세스

### 5.2 감사 및 모니터링

#### 5.2.1 모든 권한 변경 로깅

- 권한 부여/회수 모든 작업 기록
- 작업자, 대상, 시간, 이유 상세 기록
- 변경 전후 상태 비교 저장

#### 5.2.2 이상 행위 탐지

- 비정상적인 권한 접근 패턴 탐지
- 권한 남용 시도 모니터링
- 실시간 알림 시스템

#### 5.2.3 정기 감사

- 권한 할당 현황 정기 검토
- 미사용 권한 정리
- 과도한 권한 보유자 식별

### 5.3 데이터 보호

#### 5.3.1 민감 정보 암호화

- 개인정보 필드 암호화 저장
- 데이터베이스 접속 정보 암호화
- 로그에서 민감 정보 마스킹

#### 5.3.2 접근 제어

- 데이터베이스 레벨 접근 제어
- 네트워크 레벨 보안 (방화벽, VPN)
- 애플리케이션 레벨 인증/인가

## 6. 확장성 고려사항

### 6.1 수평 확장

#### 6.1.1 서비스 분리

- 권한 검증 서비스 독립화
- 마이크로서비스 아키텍처 지원
- API Gateway를 통한 중앙 집중식 권한 관리

#### 6.1.2 데이터베이스 확장

- 읽기 전용 복제본 활용
- 샤딩을 통한 대용량 데이터 처리
- 캐시 클러스터 구성

### 6.2 기능 확장

#### 6.2.1 새로운 권한 타입 추가

- 플러그인 형태의 권한 모듈
- 동적 권한 정의 지원
- 외부 시스템과의 권한 연동

#### 6.2.2 다양한 인증 방식 지원

- OAuth 2.0 / OpenID Connect
- SAML 2.0
- LDAP / Active Directory 연동

### 6.3 운영 편의성

#### 6.3.1 권한 템플릿

- 역할별 권한 템플릿 제공
- 신규 서비스 추가 시 권한 자동 생성
- 권한 복사 및 이관 기능

#### 6.3.2 시각적 권한 관리

- 권한 매트릭스 UI
- 권한 플로우 다이어그램
- 권한 변경 영향도 분석

#### 6.3.3 자동화

- 권한 정책 기반 자동 할당
- 조직 변경 시 권한 자동 업데이트
- 권한 유효성 자동 검증

## 7. 개별 사이트 적용 방안

### 7.1 스키마 재사용

#### 7.1.1 테이블 구조 표준화

- 통합 DB와 동일한 테이블 구조 사용
- service_id를 통한 권한 범위 제한
- 로컬 관리자와 통합 관리자 구분

#### 7.1.2 권한 동기화

- 통합 DB에서 개별 사이트로 권한 동기화
- 실시간 또는 배치 방식 선택 가능
- 충돌 해결 정책 정의

### 7.2 독립적 운영

#### 7.2.1 로컬 권한 관리

- 개별 사이트별 독립적인 권한 설정
- 통합 관리자의 원격 권한 관리
- 로컬 관리자의 제한적 권한 관리

#### 7.2.2 보안 격리

- 사이트 간 권한 정보 격리
- 각 사이트별 별도 암호화 키
- 네트워크 레벨 격리 정책

이 설계를 통해 통합 CMS에서 요구되는 모든 권한 관리 기능을 구조적으로 완전하게 구현할 수 있으며, 개별 사이트에서도 동일한 수준의 권한 관리 기능을 제공할 수 있습니다.
