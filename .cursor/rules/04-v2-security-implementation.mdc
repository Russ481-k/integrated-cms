---
globs: *.java,*.ts,*.tsx
description: v2 ë³´ì•ˆ ì‹œìŠ¤í…œ êµ¬í˜„ ê°€ì´ë“œ (í•˜ì´ë¸Œë¦¬ë“œ ê³„ì¸µ êµ¬ì¡°)
---

# v2 ë³´ì•ˆ ì‹œìŠ¤í…œ êµ¬í˜„ ê°€ì´ë“œ

## ğŸ›¡ï¸ í•˜ì´ë¸Œë¦¬ë“œ ë³´ì•ˆ ê³„ì¸µ êµ¬ì¡°

### 3ê³„ì¸µ ë³´ì•ˆ ì „ëµ

1. **SecurityConfig**: ê¸°ë³¸ ë³´ì•ˆ ì •ì±… + í° ë„ë©”ì¸ ë¶„ë¥˜
2. **ì»¤ìŠ¤í…€ ì–´ë…¸í…Œì´ì…˜**: ê³µí†µ ë¹„ì¦ˆë‹ˆìŠ¤ ê¶Œí•œ ë¡œì§
3. **ì»¨íŠ¸ë¡¤ëŸ¬**: ì„¸ë°€í•œ ë©”ì„œë“œë³„ ì œì–´

## ğŸ”§ ë°±ì—”ë“œ ë³´ì•ˆ êµ¬í˜„

### 1. í†µí•© ë°±ì—”ë“œ ë¼ìš°íŒ… ê¸°ë°˜ ë³´ì•ˆ ì„¤ì •

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class UnifiedCmsSecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .cors().configurationSource(corsConfigurationSource())
            .and()
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests(authz -> authz
                // ê¸°ë³¸ ê³µê°œ ê²½ë¡œ
                .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                .requestMatchers("/login/**", "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                .requestMatchers("/api/v2/auth/**").permitAll()

                                // í†µí•© ê´€ë¦¬ ì˜ì—­ - integrated_cms ê´€ë ¨
                .requestMatchers("/api/v2/integrated-cms/**")
                    .hasAnyRole("SUPER_ADMIN", "SERVICE_ADMIN")

                // ì„œë¹„ìŠ¤ë³„ CMS API - ê³„ì¸µì  ê¶Œí•œ
                .requestMatchers("/api/v2/cms/**")
                    .hasAnyRole("SUPER_ADMIN", "SERVICE_ADMIN", "SITE_ADMIN", "ADMIN")

                // ê¸°ì¡´ v1 ê²½ë¡œ ìœ ì§€ (í˜¸í™˜ì„±)
                .requestMatchers("/cms/**").authenticated()
                .requestMatchers("/egov/**").authenticated()

                // ë‚˜ë¨¸ì§€ëŠ” ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì„¸ë°€í•˜ê²Œ ì œì–´
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(jwtAuthenticationEntryPoint);

        return http.build();
    }
}
```

### 2. ì»¤ìŠ¤í…€ ë³´ì•ˆ ì–´ë…¸í…Œì´ì…˜

```java
// ì„œë¹„ìŠ¤ ì ‘ê·¼ ê¶Œí•œ
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("@serviceAccessChecker.hasAccess(authentication, #serviceId)")
public @interface RequireServiceAccess {}

// í†µí•© ê¶Œí•œ
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("@unifiedPermissionService.hasPermission(authentication, #resource, #action)")
public @interface UnifiedPermission {
    String resource();
    String action();
}

// ì„œë¹„ìŠ¤ ê´€ë¦¬ì
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("hasRole('SERVICE_ADMIN') and @serviceAccessChecker.isServiceAdmin(authentication, #serviceId)")
public @interface ServiceAdmin {}

// ì½˜í…ì¸  ê¶Œí•œ
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("@contentPermissionChecker.canAccess(authentication, #serviceId, #contentType, #action)")
public @interface ContentAccess {
    String contentType() default "GENERAL";
    String action(); // READ, WRITE, DELETE
}
```

### 3. ê¶Œí•œ ê²€ì¦ Service êµ¬í˜„

```java
@Component("serviceAccessChecker")
public class ServiceAccessChecker {

    @Autowired
    private ServiceRepository serviceRepository;

    @Autowired
    private AdminUserService adminUserService;

    public boolean hasAccess(Authentication authentication, String serviceId) {
        String username = authentication.getName();
        AdminUser user = adminUserService.findByUsername(username);

        // SYSTEM_ADMINì€ ëª¨ë“  ì„œë¹„ìŠ¤ ì ‘ê·¼ ê°€ëŠ¥
        if (user.getRole() == Role.SYSTEM_ADMIN) {
            return true;
        }

        // ì„œë¹„ìŠ¤ë³„ ê¶Œí•œ í™•ì¸
        return serviceRepository.hasUserAccess(serviceId, user.getUuid());
    }

    public boolean isServiceAdmin(Authentication authentication, String serviceId) {
        String username = authentication.getName();
        AdminUser user = adminUserService.findByUsername(username);

        return serviceRepository.isServiceAdmin(serviceId, user.getUuid());
    }
}

@Component("unifiedPermissionService")
public class UnifiedPermissionService {

    public boolean hasPermission(Authentication authentication, String resource, String action) {
        String username = authentication.getName();
        // í†µí•© ê¶Œí•œ ì‹œìŠ¤í…œì—ì„œ ê¶Œí•œ í™•ì¸
        return permissionRepository.checkPermission(username, resource, action);
    }
}
```

### 4. ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì„¸ë°€í•œ ê¶Œí•œ ì œì–´

```java
// í†µí•© ê´€ë¦¬ ì»¨íŠ¸ë¡¤ëŸ¬ (integrated_cms DB ì ‘ê·¼)
@RestController
@RequestMapping("/api/v2/integrated-cms")
@PreAuthorize("hasAnyRole('SUPER_ADMIN', 'SERVICE_ADMIN')")
public class IntegratedCmsController {

    private final AdminUserService adminUserService;
    private final SystemService systemService;
    private final ServiceManagementService serviceManagementService;

    @PreAuthorize("hasRole('SUPER_ADMIN')")
    @GetMapping("/admins")
    public ResponseEntity<ApiResponseSchema<List<AdminUserDto>>> getAdminUsers() {
        List<AdminUserDto> users = adminUserService.getAllAdminUsers();
        return ResponseEntity.ok(ApiResponseSchema.success(users));
    }

    @GetMapping("/permissions")
    public ResponseEntity<ApiResponseSchema<List<PermissionDto>>> getPermissions() {
        List<PermissionDto> permissions = systemService.getAllPermissions();
        return ResponseEntity.ok(ApiResponseSchema.success(permissions));
    }

    @GetMapping("/services")
    public ResponseEntity<ApiResponseSchema<List<ServiceDto>>> getServices() {
        List<ServiceDto> services = serviceManagementService.getAllServices();
        return ResponseEntity.ok(ApiResponseSchema.success(services));
    }

    @PostMapping("/services")
    @PreAuthorize("hasRole('SUPER_ADMIN')")
    public ResponseEntity<ApiResponseSchema<ServiceDto>> createService(@RequestBody CreateServiceRequest request) {
        ServiceDto service = serviceManagementService.createService(request);
        return ResponseEntity.ok(ApiResponseSchema.success(service, "ì„œë¹„ìŠ¤ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤."));
    }
}

// ì„œë¹„ìŠ¤ë³„ CMS ì»¨íŠ¸ë¡¤ëŸ¬ (ê° ì„œë¹„ìŠ¤ DBì— ë™ì  ë¼ìš°íŒ…)
@RestController
@RequestMapping("/api/v2/cms/{serviceId}/content")
@PreAuthorize("hasAnyRole('SUPER_ADMIN', 'SERVICE_ADMIN', 'SITE_ADMIN', 'ADMIN')")
public class CmsContentController {

    private final ContentService contentService; // ê¸°ì¡´ Service ì¬ì‚¬ìš©

    @GetMapping
    public ResponseEntity<ApiResponseSchema<Page<ContentDto>>> getContents(
            @PathVariable String serviceId,
            Pageable pageable) {

        // ServiceContextHolderì— ì˜í•´ ìë™ìœ¼ë¡œ ì ì ˆí•œ DBì— ì—°ê²°ë¨
        Page<ContentDto> contents = contentService.getAllContents(pageable);
        return ResponseEntity.ok(ApiResponseSchema.success(contents));
    }

    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'SERVICE_ADMIN')")
    @PostMapping
    public ResponseEntity<ApiResponseSchema<ContentDto>> createContent(
            @PathVariable String serviceId,
            @RequestBody ContentDto contentDto) {

        ContentDto created = contentService.createContent(contentDto);
        return ResponseEntity.ok(ApiResponseSchema.success(created, "ì½˜í…ì¸ ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤."));
    }

    @PreAuthorize("@contentPermissionChecker.canDelete(authentication, #serviceId, #id)")
    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponseSchema<Void>> deleteContent(
            @PathVariable String serviceId,
            @PathVariable Long id) {

        contentService.deleteContent(id);
        return ResponseEntity.ok(ApiResponseSchema.success("ì½˜í…ì¸ ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."));
    }
}
```

## ğŸ” í”„ë¡ íŠ¸ì—”ë“œ ë³´ì•ˆ êµ¬í˜„

### 1. ë¼ìš°íŠ¸ ë³´í˜¸

```typescript
// middleware.ts
import { NextRequest, NextResponse } from "next/server";
import { getToken } from "@/lib/auth-utils";

export function middleware(request: NextRequest) {
  const token = getToken(request);

  // v2 API ê²½ë¡œ ë³´í˜¸
  if (
    request.nextUrl.pathname.startsWith("/api/v2/") &&
    !request.nextUrl.pathname.startsWith("/api/v2/auth/") &&
    !request.nextUrl.pathname.startsWith("/api/v2/public/")
  ) {
    if (!token) {
      return NextResponse.redirect(new URL("/login", request.url));
    }
  }

  // CMS ê´€ë¦¬ í˜ì´ì§€ ë³´í˜¸
  if (request.nextUrl.pathname.startsWith("/cms/")) {
    if (!token) {
      return NextResponse.redirect(new URL("/cms/login", request.url));
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/cms/:path*", "/api/v2/:path*"],
};
```

### 2. ì»´í¬ë„ŒíŠ¸ ë ˆë²¨ ê¶Œí•œ ê²€ì¦

```typescript
// components/auth/AuthGuard.tsx
interface AuthGuardProps {
  children: React.ReactNode;
  requireRole?: UserRole;
  requireServiceAccess?: boolean;
  fallback?: React.ReactNode;
}

export const AuthGuard: React.FC<AuthGuardProps> = ({
  children,
  requireRole,
  requireServiceAccess,
  fallback = <div>ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.</div>,
}) => {
  const { user } = useAuthStore();
  const { serviceId } = useServiceContext();

  // ì¸ì¦ í™•ì¸
  if (!user) {
    return <div>ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.</div>;
  }

  // ì—­í•  í™•ì¸
  if (requireRole && !hasRole(user, requireRole)) {
    return fallback;
  }

  // ì„œë¹„ìŠ¤ ì ‘ê·¼ ê¶Œí•œ í™•ì¸
  if (requireServiceAccess && !hasServiceAccess(user, serviceId)) {
    return fallback;
  }

  return <>{children}</>;
};

// ì‚¬ìš© ì˜ˆì‹œ
<AuthGuard requireRole="SERVICE_ADMIN" requireServiceAccess>
  <ContentManagementPanel />
</AuthGuard>;
```

### 3. Hook ê¸°ë°˜ ê¶Œí•œ ê²€ì¦

```typescript
// hooks/usePermissions.ts
export const usePermissions = () => {
  const { user } = useAuthStore();
  const { serviceId } = useServiceContext();

  const hasRole = useCallback(
    (role: UserRole) => {
      return user?.role === role || user?.role === "SYSTEM_ADMIN";
    },
    [user]
  );

  const hasServiceAccess = useCallback(
    (targetServiceId?: string) => {
      if (!user) return false;
      if (user.role === "SYSTEM_ADMIN") return true;

      const checkServiceId = targetServiceId || serviceId;
      return user.accessibleServices?.includes(checkServiceId) || false;
    },
    [user, serviceId]
  );

  const canManageContent = useCallback(
    (contentType: string = "GENERAL") => {
      if (!hasServiceAccess()) return false;

      return (
        user?.permissions?.some(
          (p) =>
            p.resource === "CONTENT" &&
            p.action === "WRITE" &&
            p.resourceType === contentType
        ) || false
      );
    },
    [user, hasServiceAccess]
  );

  return {
    hasRole,
    hasServiceAccess,
    canManageContent,
    isSystemAdmin: user?.role === "SYSTEM_ADMIN",
    isServiceAdmin: hasRole("SERVICE_ADMIN"),
  };
};
```

### 4. API í˜¸ì¶œ ì‹œ ê¶Œí•œ ì²´í¬

```typescript
// hooks/useSecureApi.ts
export const useSecureApi = () => {
  const { hasServiceAccess, hasRole } = usePermissions();
  const { serviceId } = useServiceContext();

  const secureApiCall = useCallback(
    async <T>(
      apiCall: () => Promise<T>,
      requiredPermissions?: {
        role?: UserRole;
        serviceAccess?: boolean;
        action?: string;
      }
    ): Promise<T> => {
      // í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ê¶Œí•œ ê²€ì¦ (ì¶”ê°€ ë³´ì•ˆ)
      if (requiredPermissions?.role && !hasRole(requiredPermissions.role)) {
        throw new Error("ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.");
      }

      if (requiredPermissions?.serviceAccess && !hasServiceAccess()) {
        throw new Error("ì„œë¹„ìŠ¤ ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.");
      }

      return await apiCall();
    },
    [hasServiceAccess, hasRole]
  );

  return { secureApiCall };
};

// ì‚¬ìš© ì˜ˆì‹œ
const { secureApiCall } = useSecureApi();

const handleDeleteContent = async (id: number) => {
  try {
    await secureApiCall(() => contentApi.deleteContent(serviceId, id), {
      serviceAccess: true,
      action: "DELETE",
    });
    toast.success("ì½˜í…ì¸ ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
  } catch (error) {
    toast.error(error.message);
  }
};
```

## ğŸ” ë³´ì•ˆ ê°ì‚¬ ë° ë¡œê¹…

### ë°±ì—”ë“œ ê°ì‚¬ ë¡œê·¸

```java
@Aspect
@Component
public class SecurityAuditAspect {

    @Around("@annotation(requireServiceAccess)")
    public Object auditServiceAccess(ProceedingJoinPoint joinPoint, RequireServiceAccess requireServiceAccess) throws Throwable {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth.getName();
        String methodName = joinPoint.getSignature().getName();

        try {
            Object result = joinPoint.proceed();
            auditLogger.logSuccess(username, methodName, "SERVICE_ACCESS");
            return result;
        } catch (AccessDeniedException e) {
            auditLogger.logFailure(username, methodName, "SERVICE_ACCESS_DENIED", e.getMessage());
            throw e;
        }
    }
}
```

### í”„ë¡ íŠ¸ì—”ë“œ ë³´ì•ˆ ì´ë²¤íŠ¸ ì¶”ì 

```typescript
// utils/securityTracker.ts
export const securityTracker = {
  trackPermissionCheck: (action: string, result: boolean, context?: any) => {
    console.log(
      `[Security] ${action}: ${result ? "ALLOWED" : "DENIED"}`,
      context
    );

    // ìš´ì˜ í™˜ê²½ì—ì„œëŠ” ì„œë²„ë¡œ ì „ì†¡
    if (process.env.NODE_ENV === "production" && !result) {
      analytics.track("security_permission_denied", {
        action,
        context,
        timestamp: new Date().toISOString(),
      });
    }
  },

  trackUnauthorizedAccess: (path: string, user?: User) => {
    console.warn(`[Security] Unauthorized access attempt to ${path}`, user);

    analytics.track("security_unauthorized_access", {
      path,
      userId: user?.id,
      timestamp: new Date().toISOString(),
    });
  },
};
```
