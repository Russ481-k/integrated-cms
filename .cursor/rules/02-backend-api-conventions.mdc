---
globs: *.java,*.kt,*.sql,*.yml,*.yaml,*.xml
description: 통합 CMS v2 백엔드 API 개발 컨벤션 및 표준
---

# 통합 CMS v2 백엔드 API 개발 컨벤션

## 🛠️ 기술 스택

### Core Framework

- **Spring Boot 3.x** + Spring Security 6.x
- **JPA/Hibernate** + HikariCP + AbstractRoutingDataSource
- **통합 백엔드 라우팅**: 단일 애플리케이션 내부 서비스 컨텍스트 라우팅
- **MySQL 8.x** / MariaDB

### 🚨 중요: Import 패키지 규칙

**현재 프로젝트에서는 `javax.*` 패키지를 사용합니다:**

```java
// ✅ 올바른 사용
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;
import javax.validation.constraints.NotNull;

// ❌ 사용 금지 - Jakarta 패키지
import jakarta.servlet.http.HttpServletRequest;  // 사용하지 말 것
import jakarta.validation.Valid;                 // 사용하지 말 것
```

**적용 대상:**

- `javax.servlet.*` - 서블릿 관련 클래스
- `javax.validation.*` - 검증 어노테이션
- `javax.persistence.*` - JPA 관련 클래스
- 기타 모든 `javax.*` 패키지

**이유:**

- 프로젝트 전체의 일관성 유지
- 기존 코드와의 호환성 보장
- Spring Boot 버전과 관계없이 통일된 import 규칙 적용

### 인증 및 보안

- **JWT 기반 인증**: Access Token (15분) + Refresh Token (7일)
- **AES-256 암호화**: DB 연결 정보 등 민감 데이터
- **동적 데이터소스**: ServiceContext 기반 DB 라우팅

## 📁 패키지 구조

```
src/main/java/api/v2/cms/
├── config/            # 설정 클래스 (라우팅, 보안 등)
├── integrated_cms/    # 통합 CMS 관리 컨트롤러
├── auth/              # 인증/인가 관련
├── content/           # 콘텐츠 관리 (재사용)
├── menu/              # 메뉴 관리 (재사용)
├── board/             # 게시판 관리 (재사용)
└── user/              # 사용자 관리 (재사용)
```

## 🔗 통합 백엔드 라우팅 구현

### 1. Enhanced ServiceContext 시스템 (v2.1)

**핵심 컴포넌트**:
- **DynamicServiceDataSourceManager**: 서비스별 데이터소스 동적 생성 및 관리
- **EnhancedContextRoutingDataSource**: ServiceContext 기반 동적 DB 라우팅 + 동적 데이터소스 지원
- **ServiceContextInterceptor**: URL 패턴 → 서비스 ID 매핑 (정규식 기반)

**동적 서비스 지원**:
- 환경변수 기반 서비스 자동 감지 (`{SERVICE_ID}_DATASOURCE_URL` 패턴)
- 런타임 서비스 추가/제거 API 제공
- 서비스별 독립 커넥션 풀 관리

### 2. 서비스 컨텍스트 관리

- **ServiceContextHolder**: ThreadLocal로 요청별 서비스 ID 보관
- **ServiceContextInterceptor**: URL 패턴 → 서비스 ID 매핑
- **RoutingDataSourceConfig**: 서비스 ID 기반 동적 DB 연결

### 3. URL 패턴 및 라우팅 규칙

**통합 CMS (메타 관리)**:
- `/api/v2/integrated-cms/**` → `integrated_cms` DB 접근
- 관리 대상: 서비스 목록, 통합 관리자, 권한 체계

**개별 서비스 CMS (실제 콘텐츠)**:
- `/api/v2/cms/{serviceId}/**` → 해당 서비스 DB 접근
- 관리 대상: 콘텐츠, 메뉴, 사용자 등 실제 비즈니스 데이터

**동적 서비스 관리**:
- `/api/v2/integrated-cms/services/**` → 서비스 메타데이터 관리 API

### 4. WebConfig 설정

- 모든 `@RestController`에 `/api/v2` 프리픽스 자동 적용
- 컨트롤러는 상대 경로만 사용: `@RequestMapping("/integrated-cms")`
- 인터셉터 등록으로 서비스 컨텍스트 자동 주입

## 🔐 하이브리드 보안 시스템

### 권한 체계 (RBAC + ABAC)

- **SUPER_ADMIN**: 시스템 전체 관리 (모든 DB 접근)
- **SERVICE_ADMIN**: 특정 서비스 관리
- **SITE_ADMIN**: 사이트 관리자
- **ADMIN**: 일반 관리자
- **USER**: 일반 사용자

### 3계층 보안 구조

**1단계: SecurityConfig (Spring Security)**

- URL 패턴별 기본 권한 설정
- `/api/v2/integrated-cms/**`: SUPER_ADMIN, SERVICE_ADMIN
- `/api/v2/cms/**`: SUPER_ADMIN, SERVICE_ADMIN, SITE_ADMIN, ADMIN

**2단계: 커스텀 어노테이션**

- `@RequireIntegratedCmsAccess`: 통합 CMS 접근 권한
- `@RequireServiceAccess("#serviceId")`: 서비스별 접근 권한
- `@RequireContentPermission`: 콘텐츠별 세부 권한

**3단계: 컨트롤러 메서드**

- `@PreAuthorize`: SpEL 기반 세밀한 권한 제어
- 비즈니스 로직 내 추가 권한 검증

## ⚠️ 중요: API 버전 정책

### 엔드포인트 경로 규칙

- **모든 v2 엔드포인트는 `/api/v2/` 프리픽스 사용**
- **컨트롤러는 상대 경로만 지정**: `@RequestMapping("/integrated-cms")`
- **WebConfig의 `addPathPrefix` 설정으로 자동 프리픽스 적용**

### 🚨 하드코딩된 URL 주의사항

- 서비스 클래스에서 `/api/v1` 사용 금지
- 응답 객체의 endpoint 필드는 상대 경로 사용
- 파일 다운로드/뷰 URL도 `/api/v2` 사용

## 📋 API 응답 표준화

### 표준 응답 구조 (ApiResponseSchema)

모든 API는 일관된 응답 구조를 사용합니다:

- `success`: 성공 여부 (boolean)
- `message`: 응답 메시지 (string, optional)
- `data`: 실제 데이터 (T, optional)
- `errorCode`: 에러 코드 (string, optional)
- `stackTrace`: 스택 트레이스 (string, 개발 환경에서만)

### HTTP 상태 코드 규칙

- **200**: 성공 (조회, 수정, 삭제)
- **201**: 생성 성공
- **400**: 잘못된 요청 (검증 실패)
- **401**: 인증 실패
- **403**: 권한 없음
- **404**: 리소스 없음
- **500**: 서버 오류

## 🚨 예외 처리 및 에러 관리

### 글로벌 예외 처리 (@ControllerAdvice)

- `ValidationException`: 400 + 상세 검증 오류
- `UnauthorizedException`: 401 + 인증 오류
- `ForbiddenException`: 403 + 권한 오류
- `NotFoundException`: 404 + 리소스 없음
- `ServiceException`: 500 + 비즈니스 로직 오류

### 에러 코드 체계

- `ERR_AUTH_001`: 로그인 실패
- `ERR_PERM_001`: 권한 없음
- `ERR_VALID_001`: 검증 실패
- `ERR_SYS_001`: 시스템 오류

## 🔄 기존 자산 재사용 패턴

### Service Layer 100% 재사용

- 기존 비즈니스 로직 그대로 사용
- 새 컨트롤러에서 기존 서비스 주입
- 권한 검증만 어댑터 패턴으로 추가

### Repository Layer 재사용

- 기존 JPA Repository 인터페이스 활용
- 동적 데이터소스로 DB만 변경
- 쿼리 메서드 시그니처 유지

### Domain Model 90% 재사용

- 기존 Entity 클래스 그대로 사용
- 필요시 v2 전용 DTO 추가
- 매핑 로직은 MapStruct 활용

## 🗃️ 데이터베이스 접근 정책

### 이중 접근 권한 구조

- **integrated.admin 계정**: 통합 DB + 모든 서비스 DB (SUPER_ADMIN/SERVICE_ADMIN 사용)
- **admin 계정**: 서비스별 DB만 접근 (SITE_ADMIN/ADMIN 사용)

### Enhanced 동적 DataSource 설정

- **Primary**: `integrated_cms` (기본값)
- **Secondary**: 서비스별 DB (ServiceContext 기반 라우팅)
- **Connection Pool**: HikariCP (서비스별 독립 풀)
- **동적 생성**: 환경변수 기반 런타임 데이터소스 생성
- **관리 API**: `/api/v2/integrated-cms/services/**`로 서비스 추가/제거

### 환경변수 패턴

```bash
# 기본 서비스
INTEGRATED_CMS_DATASOURCE_URL=jdbc:mariadb://db:3306/integrated_cms
INTEGRATED_DB_USERNAME=integrated_admin
INTEGRATED_DB_PASSWORD=integrated123!

# 개별 서비스 (패턴: {SERVICE_ID_UPPERCASE}_*)
DOUZONE_DATASOURCE_URL=jdbc:mariadb://db:3306/douzone
DOUZONE_DB_USERNAME=admin
DOUZONE_DB_PASSWORD=admin123!

SERVICE1_DATASOURCE_URL=jdbc:mariadb://db:3306/service1
SERVICE1_DB_USERNAME=service1_user
SERVICE1_DB_PASSWORD=service1_pass
```

## 🧪 테스트 전략

### 단위 테스트

- Service Layer: 비즈니스 로직 검증
- Repository: @DataJpaTest로 DB 로직 테스트
- Controller: @WebMvcTest로 API 계층 테스트

### 통합 테스트

- @SpringBootTest로 전체 플로우 검증
- TestContainers로 실제 DB 환경 테스트
- 서비스별 라우팅 동작 검증

## 📝 API 문서화

### OpenAPI 3.0 (Swagger)

- 모든 엔드포인트 문서화 필수
- 요청/응답 예시 제공
- 권한 요구사항 명시

### 태그 분류 체계

- `Integrated CMS`: 통합 관리 API
- `Content Management`: 콘텐츠 관리
- `User Management`: 사용자 관리
- `Authentication`: 인증 관련

## 🔧 개발 도구 및 최적화

### 로깅 전략

- 서비스 컨텍스트 정보 포함
- 성능 메트릭 수집 (API 응답 시간)
- 보안 이벤트 로깅 (인증 실패, 권한 위반)

### 성능 최적화

- JPA N+1 문제 방지: @EntityGraph 활용
- 쿼리 최적화: 인덱스 적절히 설정
- 캐시 전략: Spring Cache 활용

### 모니터링

- Actuator 엔드포인트로 헬스 체크
- 메트릭 수집: Micrometer + Prometheus
- DB 커넥션 풀 모니터링
