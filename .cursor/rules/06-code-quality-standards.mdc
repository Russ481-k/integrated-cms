---
globs: *.java,*.ts,*.tsx,*.js,*.jsx
description: ì½”ë“œ í’ˆì§ˆ í‘œì¤€ ë° ê°œë°œ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤
---

# ì½”ë“œ í’ˆì§ˆ í‘œì¤€ ë° ê°œë°œ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

## ğŸ¯ ì½”ë“œ ì‘ì„± ì›ì¹™

### 1. SOLID ì›ì¹™ ì ìš©

- **Single Responsibility**: í´ë˜ìŠ¤ëŠ” í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°€ì ¸ì•¼ í•¨
- **Open/Closed**: í™•ì¥ì—ëŠ” ì—´ë ¤ìˆê³  ìˆ˜ì •ì—ëŠ” ë‹«í˜€ìˆì–´ì•¼ í•¨
- **Liskov Substitution**: ìƒìœ„ íƒ€ì…ì˜ ê°ì²´ë¥¼ í•˜ìœ„ íƒ€ì…ìœ¼ë¡œ ì¹˜í™˜ ê°€ëŠ¥í•´ì•¼ í•¨
- **Interface Segregation**: í´ë¼ì´ì–¸íŠ¸ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´í•˜ë©´ ì•ˆë¨
- **Dependency Inversion**: ê³ ìˆ˜ì¤€ ëª¨ë“ˆì€ ì €ìˆ˜ì¤€ ëª¨ë“ˆì— ì˜ì¡´í•˜ë©´ ì•ˆë¨

### 2. DRY (Don't Repeat Yourself) ì›ì¹™

- ì¤‘ë³µ ì½”ë“œ ì œê±°
- ê³µí†µ ë¡œì§ì˜ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜í™”
- ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸ ì„¤ê³„

## ğŸ—ï¸ ë°±ì—”ë“œ ì½”ë“œ í’ˆì§ˆ ê¸°ì¤€

### 1. í´ë˜ìŠ¤ ë° ë©”ì„œë“œ ì„¤ê³„

```java
// âœ… ì¢‹ì€ ì˜ˆì‹œ: ì±…ì„ì´ ëª…í™•í•œ í´ë˜ìŠ¤
@Service
@Transactional
public class ContentManagementService {

    private final ContentRepository contentRepository;
    private final ContentValidator contentValidator;
    private final ContentNotificationService notificationService;

    public ContentDto createContent(String serviceId, CreateContentRequest request) {
        // 1. ì…ë ¥ ê²€ì¦
        contentValidator.validateCreateRequest(request);

        // 2. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì²˜ë¦¬
        Content content = Content.builder()
                .serviceId(serviceId)
                .title(request.getTitle())
                .content(request.getContent())
                .status(ContentStatus.DRAFT)
                .build();

        // 3. ì €ì¥ ë° í›„ì²˜ë¦¬
        Content saved = contentRepository.save(content);
        notificationService.notifyContentCreated(saved);

        return ContentMapper.toDto(saved);
    }
}

// âŒ ë‚˜ìœ ì˜ˆì‹œ: ë„ˆë¬´ ë§ì€ ì±…ì„ì„ ê°€ì§„ í´ë˜ìŠ¤
@Service
public class ContentService {
    // ì½˜í…ì¸  CRUD + ì•Œë¦¼ + ê²€ì¦ + íŒŒì¼ ì²˜ë¦¬ + ê¶Œí•œ ì²´í¬ ë“± ëª¨ë“  ê²ƒì„ ì²˜ë¦¬
}
```

### 2. ì˜ˆì™¸ ì²˜ë¦¬ ë° ë¡œê¹…

```java
// âœ… êµ¬ì²´ì ì´ê³  ì˜ë¯¸ìˆëŠ” ì˜ˆì™¸ ì²˜ë¦¬
@Service
public class UserService {

    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    public UserDto createUser(CreateUserRequest request) {
        try {
            logger.info("Creating user: {}", request.getUsername());

            if (userRepository.existsByUsername(request.getUsername())) {
                throw new DuplicateUsernameException("Username already exists: " + request.getUsername());
            }

            User user = userMapper.toEntity(request);
            User saved = userRepository.save(user);

            logger.info("User created successfully: {}", saved.getUuid());
            return userMapper.toDto(saved);

        } catch (DataIntegrityViolationException e) {
            logger.error("Database constraint violation while creating user: {}", request.getUsername(), e);
            throw new UserCreationException("Failed to create user due to data constraint", e);
        } catch (Exception e) {
            logger.error("Unexpected error while creating user: {}", request.getUsername(), e);
            throw new UserCreationException("Failed to create user", e);
        }
    }
}

// âŒ ë‚˜ìœ ì˜ˆì‹œ: êµ¬ì²´ì ì´ì§€ ì•Šì€ ì˜ˆì™¸ ì²˜ë¦¬
public UserDto createUser(CreateUserRequest request) {
    try {
        // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
        return result;
    } catch (Exception e) {
        logger.error("Error", e);
        throw new RuntimeException("Something went wrong");
    }
}
```

### 3. ë°ì´í„° ê²€ì¦ ë° ë³€í™˜

```java
// âœ… ëª…í™•í•œ ê²€ì¦ ë° ë³€í™˜ ë¡œì§
@Component
public class ContentValidator {

    public void validateCreateRequest(CreateContentRequest request) {
        ValidationResult result = ValidationResult.builder();

        if (StringUtils.isBlank(request.getTitle())) {
            result.addError("title", "ì œëª©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.");
        } else if (request.getTitle().length() > 100) {
            result.addError("title", "ì œëª©ì€ 100ì ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.");
        }

        if (StringUtils.isBlank(request.getContent())) {
            result.addError("content", "ë‚´ìš©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.");
        }

        if (!result.isValid()) {
            throw new ValidationException(result);
        }
    }
}

@Component
public class ContentMapper {

    public static ContentDto toDto(Content entity) {
        if (entity == null) return null;

        return ContentDto.builder()
                .id(entity.getId())
                .title(entity.getTitle())
                .content(entity.getContent())
                .status(entity.getStatus())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .build();
    }

    public static Content toEntity(CreateContentRequest request) {
        return Content.builder()
                .title(StringUtils.trim(request.getTitle()))
                .content(StringUtils.trim(request.getContent()))
                .status(ContentStatus.DRAFT)
                .build();
    }
}
```

### 4. í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ ì½”ë“œ ì„¤ê³„

```java
// âœ… ì˜ì¡´ì„± ì£¼ì…ì„ í†µí•œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ ì„¤ê³„
@Service
public class ContentService {

    private final ContentRepository contentRepository;
    private final TimeProvider timeProvider;
    private final NotificationService notificationService;

    public ContentService(
            ContentRepository contentRepository,
            TimeProvider timeProvider,
            NotificationService notificationService) {
        this.contentRepository = contentRepository;
        this.timeProvider = timeProvider;
        this.notificationService = notificationService;
    }

    public ContentDto publishContent(Long contentId) {
        Content content = contentRepository.findById(contentId)
                .orElseThrow(() -> new ContentNotFoundException(contentId));

        content.publish(timeProvider.now());
        Content published = contentRepository.save(content);

        notificationService.notifyContentPublished(published);

        return ContentMapper.toDto(published);
    }
}

// í…ŒìŠ¤íŠ¸ ì½”ë“œ
@ExtendWith(MockitoExtension.class)
class ContentServiceTest {

    @Mock private ContentRepository contentRepository;
    @Mock private TimeProvider timeProvider;
    @Mock private NotificationService notificationService;

    @InjectMocks private ContentService contentService;

    @Test
    void publishContent_Success() {
        // Given
        Long contentId = 1L;
        LocalDateTime publishTime = LocalDateTime.of(2024, 1, 1, 10, 0);
        Content content = createTestContent();

        when(contentRepository.findById(contentId)).thenReturn(Optional.of(content));
        when(timeProvider.now()).thenReturn(publishTime);
        when(contentRepository.save(any())).thenReturn(content);

        // When
        ContentDto result = contentService.publishContent(contentId);

        // Then
        assertThat(result.getStatus()).isEqualTo(ContentStatus.PUBLISHED);
        verify(notificationService).notifyContentPublished(content);
    }
}
```

## ğŸ¨ í”„ë¡ íŠ¸ì—”ë“œ ì½”ë“œ í’ˆì§ˆ ê¸°ì¤€

### 1. ì»´í¬ë„ŒíŠ¸ ì„¤ê³„ ì›ì¹™

```typescript
// âœ… ì¢‹ì€ ì˜ˆì‹œ: ë‹¨ì¼ ì±…ì„ì„ ê°€ì§„ ì»´í¬ë„ŒíŠ¸
interface ContentListProps {
  serviceId: string;
  onContentSelect?: (content: Content) => void;
  filters?: ContentFilters;
}

export const ContentList: React.FC<ContentListProps> = ({
  serviceId,
  onContentSelect,
  filters,
}) => {
  const { data: contents, isLoading, error } = useContents(serviceId, filters);

  if (isLoading) return <ContentListSkeleton />;
  if (error) return <ErrorMessage error={error} />;
  if (!contents?.length) return <EmptyState message="ì½˜í…ì¸ ê°€ ì—†ìŠµë‹ˆë‹¤." />;

  return (
    <VStack spacing={2}>
      {contents.map((content) => (
        <ContentListItem
          key={content.id}
          content={content}
          onClick={() => onContentSelect?.(content)}
        />
      ))}
    </VStack>
  );
};

// âŒ ë‚˜ìœ ì˜ˆì‹œ: ë„ˆë¬´ ë§ì€ ì±…ì„ì„ ê°€ì§„ ì»´í¬ë„ŒíŠ¸
export const ContentManagement = () => {
  // ëª©ë¡ ì¡°íšŒ + ìƒì„± + ìˆ˜ì • + ì‚­ì œ + í•„í„°ë§ + í˜ì´ì§€ë„¤ì´ì…˜ + ê¶Œí•œ ì²´í¬ ë“±
  // 500ì¤„ì´ ë„˜ëŠ” ì»´í¬ë„ŒíŠ¸
};
```

### 2. ì»¤ìŠ¤í…€ Hook ì„¤ê³„

```typescript
// âœ… ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ê³  í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ Hook
interface UseContentManagementOptions {
  serviceId: string;
  autoRefresh?: boolean;
  refreshInterval?: number;
}

export const useContentManagement = ({
  serviceId,
  autoRefresh = false,
  refreshInterval = 30000,
}: UseContentManagementOptions) => {
  const queryClient = useQueryClient();

  // ëª©ë¡ ì¡°íšŒ
  const {
    data: contents,
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["contents", serviceId],
    queryFn: () => contentApi.getContents(serviceId),
    enabled: !!serviceId,
    refetchInterval: autoRefresh ? refreshInterval : undefined,
  });

  // ìƒì„±
  const createMutation = useMutation({
    mutationFn: (data: CreateContentRequest) =>
      contentApi.createContent(serviceId, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["contents", serviceId] });
      toast.success("ì½˜í…ì¸ ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.");
    },
    onError: (error) => {
      toast.error(getErrorMessage(error));
    },
  });

  // ì‚­ì œ
  const deleteMutation = useMutation({
    mutationFn: (id: number) => contentApi.deleteContent(serviceId, id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["contents", serviceId] });
      toast.success("ì½˜í…ì¸ ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
    },
    onError: (error) => {
      toast.error(getErrorMessage(error));
    },
  });

  return {
    contents,
    isLoading,
    error,
    refetch,
    createContent: createMutation.mutateAsync,
    deleteContent: deleteMutation.mutateAsync,
    isCreating: createMutation.isPending,
    isDeleting: deleteMutation.isPending,
  };
};
```

### 3. íƒ€ì… ì•ˆì •ì„± ë° ê²€ì¦

```typescript
// âœ… ì—„ê²©í•œ íƒ€ì… ì •ì˜
export interface Content {
  readonly id: number;
  readonly serviceId: string;
  title: string;
  content: string;
  status: ContentStatus;
  readonly createdAt: string;
  readonly updatedAt: string;
  readonly createdBy: {
    id: string;
    name: string;
  };
}

export enum ContentStatus {
  DRAFT = "DRAFT",
  PUBLISHED = "PUBLISHED",
  ARCHIVED = "ARCHIVED",
}

// Zod ìŠ¤í‚¤ë§ˆë¥¼ í™œìš©í•œ ëŸ°íƒ€ì„ ê²€ì¦
export const CreateContentSchema = z.object({
  title: z
    .string()
    .min(1, "ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    .max(100, "ì œëª©ì€ 100ì ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤."),
  content: z
    .string()
    .min(1, "ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    .max(10000, "ë‚´ìš©ì€ 10,000ì ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤."),
  tags: z
    .array(z.string())
    .max(10, "íƒœê·¸ëŠ” ìµœëŒ€ 10ê°œê¹Œì§€ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    .optional(),
});

export type CreateContentRequest = z.infer<typeof CreateContentSchema>;

// í¼ì—ì„œ ì‚¬ìš©
export const useContentForm = (initialData?: Partial<Content>) => {
  return useForm<CreateContentRequest>({
    defaultValues: {
      title: initialData?.title || "",
      content: initialData?.content || "",
      tags: initialData?.tags || [],
    },
    resolver: zodResolver(CreateContentSchema),
  });
};
```

### 4. ì—ëŸ¬ ê²½ê³„ ë° ì˜ˆì™¸ ì²˜ë¦¬

```typescript
// âœ… ì—ëŸ¬ ê²½ê³„ ì»´í¬ë„ŒíŠ¸
interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error: Error; resetError: () => void }>;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

export class ErrorBoundary extends React.Component<
  ErrorBoundaryProps,
  { hasError: boolean; error?: Error }
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
    this.props.onError?.(error, errorInfo);

    // ì—ëŸ¬ ë¦¬í¬íŒ… ì„œë¹„ìŠ¤ë¡œ ì „ì†¡
    errorReporter.captureException(error, {
      tags: { component: "ErrorBoundary" },
      extra: errorInfo,
    });
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return (
        <FallbackComponent
          error={this.state.error!}
          resetError={() =>
            this.setState({ hasError: false, error: undefined })
          }
        />
      );
    }

    return this.props.children;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
<ErrorBoundary onError={handleError}>
  <ContentManagementPanel />
</ErrorBoundary>;
```

## ğŸ“‹ ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

### ë°±ì—”ë“œ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] **ì•„í‚¤í…ì²˜**: ë ˆì´ì–´ ê°„ ì˜ì¡´ì„±ì´ ì˜¬ë°”ë¥¸ê°€?
- [ ] **ë³´ì•ˆ**: ì¸ì¦/ì¸ê°€ê°€ ì ì ˆíˆ ì ìš©ë˜ì—ˆëŠ”ê°€?
- [ ] **ì„±ëŠ¥**: N+1 ì¿¼ë¦¬, ë¶ˆí•„ìš”í•œ DB í˜¸ì¶œì€ ì—†ëŠ”ê°€?
- [ ] **ì˜ˆì™¸ì²˜ë¦¬**: êµ¬ì²´ì ì´ê³  ì˜ë¯¸ìˆëŠ” ì˜ˆì™¸ ì²˜ë¦¬ì¸ê°€?
- [ ] **ë¡œê¹…**: ì ì ˆí•œ ë¡œê·¸ ë ˆë²¨ê³¼ ë‚´ìš©ì¸ê°€?
- [ ] **í…ŒìŠ¤íŠ¸**: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ê°€ ì‘ì„±ë˜ì—ˆëŠ”ê°€?
- [ ] **ë¬¸ì„œí™”**: API ë¬¸ì„œ(Swagger)ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆëŠ”ê°€?

### í”„ë¡ íŠ¸ì—”ë“œ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] **ì»´í¬ë„ŒíŠ¸**: ë‹¨ì¼ ì±…ì„ ì›ì¹™ì„ ì§€í‚¤ëŠ”ê°€?
- [ ] **íƒ€ì… ì•ˆì •ì„±**: TypeScriptë¥¼ ì ì ˆíˆ í™œìš©í–ˆëŠ”ê°€?
- [ ] **ì„±ëŠ¥**: ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ì€ ì—†ëŠ”ê°€?
- [ ] **ì ‘ê·¼ì„±**: ARIA ì†ì„±, í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ì´ ê³ ë ¤ë˜ì—ˆëŠ”ê°€?
- [ ] **ì—ëŸ¬ ì²˜ë¦¬**: ì‚¬ìš©ì ì¹œí™”ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€ì¸ê°€?
- [ ] **ìƒíƒœ ê´€ë¦¬**: ìƒíƒœê°€ ì ì ˆí•œ ë²”ìœ„ì—ì„œ ê´€ë¦¬ë˜ëŠ”ê°€?
- [ ] **í…ŒìŠ¤íŠ¸**: ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸ê°€ ì‘ì„±ë˜ì—ˆëŠ”ê°€?

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### ë°±ì—”ë“œ í…ŒìŠ¤íŠ¸ í”¼ë¼ë¯¸ë“œ

```java
// ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (70%)
@ExtendWith(MockitoExtension.class)
class ContentServiceTest {
    // Service ë¡œì§ í…ŒìŠ¤íŠ¸
}

// í†µí•© í…ŒìŠ¤íŠ¸ (20%)
@SpringBootTest
@Transactional
class ContentRepositoryTest {
    // Repositoryì™€ DB ì—°ë™ í…ŒìŠ¤íŠ¸
}

// E2E í…ŒìŠ¤íŠ¸ (10%)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ContentControllerE2ETest {
    // ì „ì²´ í”Œë¡œìš° í…ŒìŠ¤íŠ¸
}
```

### í”„ë¡ íŠ¸ì—”ë“œ í…ŒìŠ¤íŠ¸ í”¼ë¼ë¯¸ë“œ

```typescript
// ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (70%) - Jest + Testing Library
describe("useContentManagement", () => {
  it("should create content successfully", async () => {
    // Hook ë¡œì§ í…ŒìŠ¤íŠ¸
  });
});

// í†µí•© í…ŒìŠ¤íŠ¸ (20%) - Component + Hook í†µí•©
describe("ContentForm", () => {
  it("should submit form with valid data", async () => {
    // ì»´í¬ë„ŒíŠ¸ì™€ Hook ì—°ë™ í…ŒìŠ¤íŠ¸
  });
});

// E2E í…ŒìŠ¤íŠ¸ (10%) - Playwright/Cypress
describe("Content Management Flow", () => {
  it("should allow user to create, edit, and delete content", () => {
    // ì „ì²´ ì‚¬ìš©ì í”Œë¡œìš° í…ŒìŠ¤íŠ¸
  });
});
```
