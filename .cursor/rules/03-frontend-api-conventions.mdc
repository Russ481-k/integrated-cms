---
globs: *.ts,*.tsx,*.js,*.jsx
description: 프론트엔드 API 통신 및 개발 컨벤션
---

# 프론트엔드 API 통신 컨벤션

## 🛠️ 기술 스택

### Core Framework

- **Next.js 14** (App Router) + **React 18** + **TypeScript 5.x**
- **Chakra UI** + **TanStack Query** + **Recoil**
- **React Hook Form** + **Chart.js/Recharts**

## 📡 API 클라이언트 구조

### ⚠️ 중요: 서비스별 API 기본 URL 설정

**통합 CMS vs 서비스별 CMS 구분:**

- 통합 CMS (integrated-client): `NEXT_PUBLIC_API_BASE_URL=http://localhost:8080/api/v2/integrated-cms`
- 서비스별 CMS (douzone-client): `NEXT_PUBLIC_API_BASE_URL=http://localhost:8080/api/v2/cms/douzone`

### 기본 클라이언트 설정

- 공개 API: `publicApi.get("/auth/signup")` (인증 불필요)
- 인증 API: `privateApi.get("/user/profile")` (JWT 토큰 자동 포함)
- 상대 경로 사용: 환경변수 기반 자동 라우팅

### API 응답 타입 정의

백엔드 `ApiResponseSchema`와 일치하는 구조를 사용합니다:

```typescript
export interface ApiResponse<T = any> {
  success: boolean;
  message?: string;
  data?: T;
  errorCode?: string | null;
  stackTrace?: string | null;
}
```

## 🔐 인증 및 토큰 관리

### JWT 토큰 처리

- Access Token: HTTP-only 쿠키 또는 localStorage 저장
- Refresh Token: HTTP-only 쿠키로 보안 저장
- 토큰 만료 시 자동 갱신 로직 구현
- 401 응답 시 자동 로그아웃 처리

## 📋 API 호출 패턴

### 표준 CRUD 패턴 (하이브리드 라우팅)

**서비스별 CMS API**: 환경변수 기반 자동 라우팅으로 상대 경로 사용

- 목록 조회: `privateApi.get("/content", { params })`
- 단일 조회: `privateApi.get("/content/${id}")`
- 생성/수정/삭제: 해당 HTTP 메서드 사용

**통합 CMS 전용 API**: SUPER_ADMIN, SERVICE_ADMIN 권한 필요

- 관리자 관리: `privateApi.get("/admins")`
- 서비스 관리: `privateApi.get("/services")`
- 시스템 권한: `privateApi.get("/permissions")`

**인증 API (공통)**: 모든 클라이언트에서 동일하게 사용

- 로그인: `publicApi.post("/auth/login", credentials)`
- 사용자명 확인: `publicApi.get("/auth/check-username/${username}")`
- 토큰 갱신: `publicApi.post("/auth/refresh-token", { refreshToken })`

### TanStack Query 사용 패턴

**쿼리 키 전략**: `["resource", serviceType, params]` 형태 사용

- 서비스별 CMS: `queryKey: ["contents", serviceType, params]`
- 통합 CMS: `queryKey: ["integrated-cms", "services"]`
- 환경변수 기반 조건부 활성화: `enabled: process.env.NEXT_PUBLIC_SERVICE_TYPE === "integrated-cms"`

**뮤테이션 후 처리**:

- 성공 시: 관련 쿼리 무효화 + 성공 토스트
- 실패 시: 에러 토스트 + 에러 로깅

## 🎭 상태 관리 패턴

### Recoil 아톰 구조

**인증 상태**: `authState` 아톰으로 중앙 관리

- 사용자 정보, 인증 상태, 로딩 상태 포함
- `useAuthActions` 훅으로 login/logout/syncAuthState 제공

**서비스 컨텍스트**: 환경변수 기반 서비스 타입 관리

- `process.env.NEXT_PUBLIC_SERVICE_TYPE`으로 구분
- 통합 CMS vs 서비스별 CMS 조건부 렌더링
- 서비스 간 이동은 새 탭으로 처리

### 권한 기반 UI 렌더링

- 사용자 역할에 따른 조건부 컴포넌트 렌더링
- SUPER_ADMIN: 모든 기능 접근
- SERVICE_ADMIN: 할당된 서비스 관리
- SITE_ADMIN/ADMIN: 제한된 관리 기능

## 📝 폼 관리 및 검증

### React Hook Form 패턴

- Zod 스키마를 통한 타입 안전 검증
- `@hookform/resolvers/zod` 사용
- 에러 상태를 Chakra UI와 연동

### 로딩 상태 관리

- TanStack Query의 `isLoading`, `isFetching` 활용
- 커스텀 `useApiState` 훅으로 일관된 로딩/에러 처리

## 🎨 UI 컴포넌트 패턴

### 공통 컴포넌트 구조

- **DataTable**: 제네릭 타입으로 재사용 가능한 테이블
- **FormField**: React Hook Form과 Chakra UI 통합
- **LoadingSpinner**: 표준화된 로딩 인디케이터

### Chakra UI 사용 규칙

- **중요**: `spacing` prop 대신 `gap` 스타일 prop 사용
- 색상은 테마 토큰 사용 (`colorScheme` prop)
- 반응형 값은 객체 문법 사용: `{ base: "column", md: "row" }`

## 🚨 에러 처리 및 예외 상황

### 글로벌 에러 처리

- Axios 인터셉터로 공통 에러 처리
- 401: 자동 로그아웃 + 로그인 페이지 리다이렉트
- 403: 권한 없음 토스트 + 이전 페이지 이동
- 5xx: 서버 오류 토스트 + 에러 리포팅

### 네트워크 에러 대응

- 오프라인 상태 감지
- 재시도 로직 구현 (TanStack Query의 retry 설정)
- 타임아웃 설정 및 처리

## 📦 번들 최적화

### 코드 스플리팅

- Next.js의 자동 코드 스플리팅 활용
- `dynamic` import로 지연 로딩
- 번들 분석기로 크기 모니터링

### 성능 최적화

- React.memo로 불필요한 리렌더링 방지
- useMemo, useCallback으로 계산 최적화
- 이미지 최적화: Next.js Image 컴포넌트 사용

## 🔧 개발 도구 및 디버깅

### DevTools 활용

- TanStack Query DevTools: 쿼리 상태 디버깅
- Recoil DevTools: 상태 변화 추적
- Next.js 번들 분석기: 성능 모니터링

### 로깅 전략

- 개발 환경: console.log 활용
- 프로덕션: 에러 리포팅 서비스 연동
- API 호출 로깅: 요청/응답 시간 측정
